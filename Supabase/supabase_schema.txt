
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. PROFILES TABLE
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT,
  full_name TEXT,
  username TEXT,
  role TEXT CHECK (role IN ('admin', 'board', 'user')) DEFAULT 'user',
  car_model TEXT DEFAULT 'r53',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- MIGRATION HELPERS
DO $$ 
BEGIN 
    BEGIN
        ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS username TEXT;
    EXCEPTION
        WHEN duplicate_column THEN RAISE NOTICE 'username column already exists';
    END;
    BEGIN
        ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS full_name TEXT;
    EXCEPTION
        WHEN duplicate_column THEN RAISE NOTICE 'full_name column already exists';
    END;
    BEGIN
        ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS car_model TEXT DEFAULT 'r53';
    EXCEPTION
        WHEN duplicate_column THEN RAISE NOTICE 'car_model column already exists';
    END;
END $$;

-- 2. MEETINGS TABLE
CREATE TABLE IF NOT EXISTS public.meetings (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  title TEXT NOT NULL,
  date DATE NOT NULL,
  end_date DATE,
  location_name TEXT NOT NULL,
  description TEXT,
  cover_image_url TEXT,
  pdf_url TEXT, 
  is_pinned BOOLEAN DEFAULT false,
  maps_config JSONB DEFAULT '[]'::jsonb,
  hotel_info JSONB DEFAULT '{}'::jsonb,
  parking_info JSONB DEFAULT '{}'::jsonb,
  custom_data JSONB DEFAULT '{}'::jsonb,
  extra_info JSONB DEFAULT '[]'::jsonb
);

-- 3. ITINERARY ITEMS
CREATE TABLE IF NOT EXISTS public.itinerary_items (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  date DATE NOT NULL,
  start_time TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  location_details TEXT,
  location_map_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 4. REGISTRATIONS
CREATE TABLE IF NOT EXISTS public.registrations (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  full_name TEXT NOT NULL,
  forum_name TEXT,
  email TEXT NOT NULL,
  phone TEXT,
  car_type TEXT,
  status TEXT CHECK (status IN ('confirmed', 'pending', 'cancelled')) DEFAULT 'pending',
  registered_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 5. TRANSACTIONS
CREATE TABLE IF NOT EXISTS public.transactions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  amount NUMERIC(10,2) NOT NULL,
  type TEXT CHECK (type IN ('income', 'expense')) NOT NULL,
  date DATE NOT NULL,
  category TEXT
);

-- 6. USER ROLES (Legacy)
CREATE TABLE IF NOT EXISTS public.user_roles (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role TEXT CHECK (role IN ('admin', 'board', 'user')) DEFAULT 'user',
  UNIQUE(user_id)
);

-- 7. CONNECTION TESTS (New for diagnostics)
CREATE TABLE IF NOT EXISTS public.connection_tests (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  message TEXT,
  response_data TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 8. STORAGE
INSERT INTO storage.buckets (id, name, public) 
VALUES ('nmcs-assets', 'nmcs-assets', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- ENABLE RLS
DO $$ 
BEGIN
    EXECUTE 'ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.meetings ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.itinerary_items ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.registrations ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.connection_tests ENABLE ROW LEVEL SECURITY';
EXCEPTION
    WHEN others THEN NULL;
END $$;

-- HELPER: IS_ADMIN
-- CRITICAL: SECURITY DEFINER allows this function to bypass RLS, avoiding infinite recursion loops
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role IN ('admin', 'board')
  ) OR EXISTS (
    SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role IN ('admin', 'board')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- CLEANUP OLD POLICIES (Comprehensive)
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert own profile" ON public.profiles;
DROP POLICY IF EXISTS "Public meetings are viewable by everyone" ON public.meetings;
DROP POLICY IF EXISTS "Admins can insert meetings" ON public.meetings;
DROP POLICY IF EXISTS "Admins can update meetings" ON public.meetings;
DROP POLICY IF EXISTS "Admins can delete meetings" ON public.meetings;
DROP POLICY IF EXISTS "Public itinerary is viewable by everyone" ON public.itinerary_items;
DROP POLICY IF EXISTS "Admins can manage itinerary" ON public.itinerary_items;
DROP POLICY IF EXISTS "Public can register" ON public.registrations;
DROP POLICY IF EXISTS "Users can view own registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can view all registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can update registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can manage transactions" ON public.transactions;
DROP POLICY IF EXISTS "Users can read own role" ON public.user_roles;
DROP POLICY IF EXISTS "Admins can manage roles" ON public.user_roles;
DROP POLICY IF EXISTS "Public can test connection" ON public.connection_tests;

-- POLICIES

-- Profiles
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- Meetings
CREATE POLICY "Public meetings are viewable by everyone" ON public.meetings FOR SELECT USING (true);
CREATE POLICY "Admins can insert meetings" ON public.meetings FOR INSERT WITH CHECK (is_admin());
CREATE POLICY "Admins can update meetings" ON public.meetings FOR UPDATE USING (is_admin());
CREATE POLICY "Admins can delete meetings" ON public.meetings FOR DELETE USING (is_admin());

-- Itinerary
CREATE POLICY "Public itinerary is viewable by everyone" ON public.itinerary_items FOR SELECT USING (true);
CREATE POLICY "Admins can manage itinerary" ON public.itinerary_items FOR ALL USING (is_admin());

-- Registrations
CREATE POLICY "Public can register" ON public.registrations FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can view own registrations" ON public.registrations FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admins can view all registrations" ON public.registrations FOR SELECT USING (is_admin());
CREATE POLICY "Admins can update registrations" ON public.registrations FOR UPDATE USING (is_admin());

-- Transactions
CREATE POLICY "Admins can manage transactions" ON public.transactions FOR ALL USING (is_admin());

-- User Roles
CREATE POLICY "Users can read own role" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admins can manage roles" ON public.user_roles FOR ALL USING (is_admin());

-- Connection Tests (Allow everyone to read/write for diagnostics)
CREATE POLICY "Public can test connection" ON public.connection_tests FOR ALL USING (true) WITH CHECK (true);

-- Storage Policies
DROP POLICY IF EXISTS "Public Access" ON storage.objects;
DROP POLICY IF EXISTS "Auth Upload" ON storage.objects;
DROP POLICY IF EXISTS "Auth Update" ON storage.objects;
DROP POLICY IF EXISTS "Auth Delete" ON storage.objects;

CREATE POLICY "Public Access" ON storage.objects FOR SELECT USING ( bucket_id = 'nmcs-assets' );
CREATE POLICY "Auth Upload" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );
CREATE POLICY "Auth Update" ON storage.objects FOR UPDATE USING ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );
CREATE POLICY "Auth Delete" ON storage.objects FOR DELETE USING ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );

-- TRIGGER: HANDLE NEW USER
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  extracted_username TEXT;
  extracted_fullname TEXT;
BEGIN
  extracted_username := COALESCE(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1));
  extracted_fullname := COALESCE(new.raw_user_meta_data->>'full_name', 'New User');

  INSERT INTO public.profiles (id, email, full_name, username, role)
  VALUES (
    new.id, 
    new.email, 
    extracted_fullname,
    extracted_username,
    'user'
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    full_name = EXCLUDED.full_name,
    username = EXCLUDED.username;
    
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
