
-- Enable UUID extension (Required for uuid_generate_v4)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. PROFILES TABLE
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT,
  full_name TEXT,
  username TEXT,
  role TEXT CHECK (role IN ('admin', 'board', 'user')) DEFAULT 'user',
  car_model TEXT DEFAULT 'r53',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
-- Ensure columns exist (Migration safety)
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS username TEXT;
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS full_name TEXT;
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS car_model TEXT DEFAULT 'r53';
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- 2. CONNECTION TESTS (Diagnostics)
CREATE TABLE IF NOT EXISTS public.connection_tests (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  message TEXT,
  response_data TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.connection_tests ENABLE ROW LEVEL SECURITY;

-- 3. MEETINGS TABLE
CREATE TABLE IF NOT EXISTS public.meetings (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  title TEXT NOT NULL,
  date DATE NOT NULL,
  end_date DATE,
  location_name TEXT NOT NULL,
  description TEXT,
  cover_image_url TEXT,
  pdf_url TEXT, 
  is_pinned BOOLEAN DEFAULT false,
  maps_config JSONB DEFAULT '[]'::jsonb,
  hotel_info JSONB DEFAULT '{}'::jsonb,
  parking_info JSONB DEFAULT '{}'::jsonb,
  custom_data JSONB DEFAULT '{}'::jsonb,
  extra_info JSONB DEFAULT '[]'::jsonb
);
ALTER TABLE public.meetings ENABLE ROW LEVEL SECURITY;

-- 4. ITINERARY ITEMS
CREATE TABLE IF NOT EXISTS public.itinerary_items (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  date DATE NOT NULL,
  start_time TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  location_details TEXT,
  location_map_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.itinerary_items ENABLE ROW LEVEL SECURITY;

-- 5. REGISTRATIONS
CREATE TABLE IF NOT EXISTS public.registrations (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  full_name TEXT NOT NULL,
  forum_name TEXT,
  email TEXT NOT NULL,
  phone TEXT,
  car_type TEXT,
  status TEXT CHECK (status IN ('confirmed', 'pending', 'cancelled')) DEFAULT 'pending',
  registered_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.registrations ENABLE ROW LEVEL SECURITY;

-- 6. TRANSACTIONS
CREATE TABLE IF NOT EXISTS public.transactions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  amount NUMERIC(10,2) NOT NULL,
  type TEXT CHECK (type IN ('income', 'expense')) NOT NULL,
  date DATE NOT NULL,
  category TEXT
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- 7. USER ROLES (Legacy support)
CREATE TABLE IF NOT EXISTS public.user_roles (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role TEXT CHECK (role IN ('admin', 'board', 'user')) DEFAULT 'user',
  UNIQUE(user_id)
);
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- 8. STORAGE BUCKET
INSERT INTO storage.buckets (id, name, public) 
VALUES ('nmcs-assets', 'nmcs-assets', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- 9. ADMIN FUNCTION (SECURED)
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN 
LANGUAGE plpgsql 
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role IN ('admin', 'board')
  ) OR EXISTS (
    SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role IN ('admin', 'board')
  );
END;
$$;

-- 10. POLICIES (Drop first to allow re-running script safely)

-- Profiles
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert own profile" ON public.profiles;

CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- Connection Tests (Fixed: Split policies to avoid ALL permissiveness)
DROP POLICY IF EXISTS "Public can test connection" ON public.connection_tests;
DROP POLICY IF EXISTS "Public can insert tests" ON public.connection_tests;
DROP POLICY IF EXISTS "Public can read tests" ON public.connection_tests;

CREATE POLICY "Public can insert tests" ON public.connection_tests FOR INSERT WITH CHECK (true);
CREATE POLICY "Public can read tests" ON public.connection_tests FOR SELECT USING (true);

-- Meetings
DROP POLICY IF EXISTS "Public meetings are viewable by everyone" ON public.meetings;
DROP POLICY IF EXISTS "Admins can insert meetings" ON public.meetings;
DROP POLICY IF EXISTS "Admins can update meetings" ON public.meetings;
DROP POLICY IF EXISTS "Admins can delete meetings" ON public.meetings;

CREATE POLICY "Public meetings are viewable by everyone" ON public.meetings FOR SELECT USING (true);
CREATE POLICY "Admins can insert meetings" ON public.meetings FOR INSERT WITH CHECK (is_admin());
CREATE POLICY "Admins can update meetings" ON public.meetings FOR UPDATE USING (is_admin());
CREATE POLICY "Admins can delete meetings" ON public.meetings FOR DELETE USING (is_admin());

-- Itinerary
DROP POLICY IF EXISTS "Public itinerary is viewable by everyone" ON public.itinerary_items;
DROP POLICY IF EXISTS "Admins can manage itinerary" ON public.itinerary_items;

CREATE POLICY "Public itinerary is viewable by everyone" ON public.itinerary_items FOR SELECT USING (true);
CREATE POLICY "Admins can manage itinerary" ON public.itinerary_items FOR ALL USING (is_admin());

-- Registrations
DROP POLICY IF EXISTS "Public can register" ON public.registrations;
DROP POLICY IF EXISTS "Users can view own registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can view all registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can update registrations" ON public.registrations;

CREATE POLICY "Public can register" ON public.registrations FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can view own registrations" ON public.registrations FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admins can view all registrations" ON public.registrations FOR SELECT USING (is_admin());
CREATE POLICY "Admins can update registrations" ON public.registrations FOR UPDATE USING (is_admin());

-- Transactions
DROP POLICY IF EXISTS "Admins can manage transactions" ON public.transactions;
CREATE POLICY "Admins can manage transactions" ON public.transactions FOR ALL USING (is_admin());

-- User Roles
DROP POLICY IF EXISTS "Users can read own role" ON public.user_roles;
DROP POLICY IF EXISTS "Admins can manage roles" ON public.user_roles;

CREATE POLICY "Users can read own role" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admins can manage roles" ON public.user_roles FOR ALL USING (is_admin());

-- Storage
DROP POLICY IF EXISTS "Public Access" ON storage.objects;
DROP POLICY IF EXISTS "Auth Upload" ON storage.objects;
DROP POLICY IF EXISTS "Auth Update" ON storage.objects;
DROP POLICY IF EXISTS "Auth Delete" ON storage.objects;

CREATE POLICY "Public Access" ON storage.objects FOR SELECT USING ( bucket_id = 'nmcs-assets' );
CREATE POLICY "Auth Upload" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );
CREATE POLICY "Auth Update" ON storage.objects FOR UPDATE USING ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );
CREATE POLICY "Auth Delete" ON storage.objects FOR DELETE USING ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );

-- 11. TRIGGER: HANDLE NEW USER (SECURED)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER 
LANGUAGE plpgsql 
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  extracted_username TEXT;
  extracted_fullname TEXT;
BEGIN
  -- Try to get metadata, fallback to email part
  extracted_username := COALESCE(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1));
  extracted_fullname := COALESCE(new.raw_user_meta_data->>'full_name', 'New User');

  INSERT INTO public.profiles (id, email, full_name, username, role)
  VALUES (
    new.id, 
    new.email, 
    extracted_fullname,
    extracted_username,
    'user'
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    full_name = EXCLUDED.full_name,
    username = EXCLUDED.username;
    
  RETURN new;
END;
$$;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
