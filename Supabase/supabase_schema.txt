
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. PROFILES TABLE (New: Syncs with Auth)
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT,
  full_name TEXT,
  role TEXT CHECK (role IN ('admin', 'board', 'user')) DEFAULT 'user',
  car_model TEXT DEFAULT 'r53', -- New: Stores the user's selected car theme
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. MEETINGS TABLE
CREATE TABLE IF NOT EXISTS public.meetings (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  title TEXT NOT NULL,
  date DATE NOT NULL,
  end_date DATE,
  location_name TEXT NOT NULL,
  description TEXT,
  cover_image_url TEXT,
  is_pinned BOOLEAN DEFAULT false,
  maps_config JSONB DEFAULT '[]'::jsonb,
  hotel_info JSONB DEFAULT '{}'::jsonb,
  parking_info JSONB DEFAULT '{}'::jsonb,
  custom_data JSONB DEFAULT '{}'::jsonb,
  extra_info JSONB DEFAULT '[]'::jsonb
);
ALTER TABLE public.meetings ADD COLUMN IF NOT EXISTS end_date DATE;
ALTER TABLE public.meetings ADD COLUMN IF NOT EXISTS hotel_info JSONB DEFAULT '{}'::jsonb;
ALTER TABLE public.meetings ADD COLUMN IF NOT EXISTS parking_info JSONB DEFAULT '{}'::jsonb;
ALTER TABLE public.meetings ADD COLUMN IF NOT EXISTS extra_info JSONB DEFAULT '[]'::jsonb;

-- 3. ITINERARY ITEMS TABLE
CREATE TABLE IF NOT EXISTS public.itinerary_items (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  date DATE NOT NULL,
  start_time TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  location_details TEXT,
  location_map_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 4. REGISTRATIONS TABLE
CREATE TABLE IF NOT EXISTS public.registrations (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  full_name TEXT NOT NULL,
  forum_name TEXT,
  email TEXT NOT NULL,
  phone TEXT,
  car_type TEXT,
  status TEXT CHECK (status IN ('confirmed', 'pending', 'cancelled')) DEFAULT 'pending',
  registered_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.registrations ADD COLUMN IF NOT EXISTS car_type TEXT;

-- 5. TRANSACTIONS TABLE
CREATE TABLE IF NOT EXISTS public.transactions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meeting_id UUID REFERENCES public.meetings(id) ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  amount NUMERIC(10,2) NOT NULL,
  type TEXT CHECK (type IN ('income', 'expense')) NOT NULL,
  date DATE NOT NULL,
  category TEXT
);

-- 6. USER ROLES (Legacy/Redundant if using profiles, but keeping for compatibility if preferred)
-- We will migrate logic to use 'profiles' generally, but this table can act as a stricter override
CREATE TABLE IF NOT EXISTS public.user_roles (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role TEXT CHECK (role IN ('admin', 'board', 'user')) DEFAULT 'user',
  UNIQUE(user_id)
);

-- 7. STORAGE BUCKET SETUP (New)
-- Create a new public bucket named 'nmcs-assets' for images and PDFs
INSERT INTO storage.buckets (id, name, public) 
VALUES ('nmcs-assets', 'nmcs-assets', true)
ON CONFLICT (id) DO NOTHING;

-- ENABLE RLS
DO $$ 
BEGIN
    EXECUTE 'ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.meetings ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.itinerary_items ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.registrations ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY';
EXCEPTION
    WHEN others THEN NULL;
END $$;

-- CLEANUP OLD POLICIES
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
DROP POLICY IF EXISTS "Public meetings are viewable by everyone" ON public.meetings;
DROP POLICY IF EXISTS "Admins can insert meetings" ON public.meetings;
DROP POLICY IF EXISTS "Admins can update meetings" ON public.meetings;
DROP POLICY IF EXISTS "Admins can delete meetings" ON public.meetings;
DROP POLICY IF EXISTS "Public itinerary is viewable by everyone" ON public.itinerary_items;
DROP POLICY IF EXISTS "Admins can manage itinerary" ON public.itinerary_items;
DROP POLICY IF EXISTS "Public can register" ON public.registrations;
DROP POLICY IF EXISTS "Users can view own registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can view all registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can update registrations" ON public.registrations;
DROP POLICY IF EXISTS "Admins can manage transactions" ON public.transactions;
DROP POLICY IF EXISTS "Users can read own role" ON public.user_roles;
DROP POLICY IF EXISTS "Admins can manage roles" ON public.user_roles;

-- STORAGE POLICIES
DROP POLICY IF EXISTS "Public Access" ON storage.objects;
DROP POLICY IF EXISTS "Auth Upload" ON storage.objects;
DROP POLICY IF EXISTS "Auth Update" ON storage.objects;
DROP POLICY IF EXISTS "Auth Delete" ON storage.objects;

-- HELPER: IS_ADMIN
-- Checks both tables for robustness
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role IN ('admin', 'board')
  ) OR EXISTS (
    SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role IN ('admin', 'board')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- POLICIES

-- Profiles
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Meetings
CREATE POLICY "Public meetings are viewable by everyone" ON public.meetings FOR SELECT USING (true);
CREATE POLICY "Admins can insert meetings" ON public.meetings FOR INSERT WITH CHECK (is_admin());
CREATE POLICY "Admins can update meetings" ON public.meetings FOR UPDATE USING (is_admin());
CREATE POLICY "Admins can delete meetings" ON public.meetings FOR DELETE USING (is_admin());

-- Itinerary
CREATE POLICY "Public itinerary is viewable by everyone" ON public.itinerary_items FOR SELECT USING (true);
CREATE POLICY "Admins can manage itinerary" ON public.itinerary_items FOR ALL USING (is_admin());

-- Registrations
CREATE POLICY "Public can register" ON public.registrations FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can view own registrations" ON public.registrations FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admins can view all registrations" ON public.registrations FOR SELECT USING (is_admin());
CREATE POLICY "Admins can update registrations" ON public.registrations FOR UPDATE USING (is_admin());

-- Transactions
CREATE POLICY "Admins can manage transactions" ON public.transactions FOR ALL USING (is_admin());

-- Storage Policies
CREATE POLICY "Public Access" ON storage.objects FOR SELECT USING ( bucket_id = 'nmcs-assets' );
CREATE POLICY "Auth Upload" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );
CREATE POLICY "Auth Update" ON storage.objects FOR UPDATE USING ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );
CREATE POLICY "Auth Delete" ON storage.objects FOR DELETE USING ( bucket_id = 'nmcs-assets' AND auth.role() = 'authenticated' );

-- TRIGGER: HANDLE NEW USER
-- Automatically creates a profile row when a user signs up via Supabase Auth
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (
    new.id, 
    new.email, 
    COALESCE(new.raw_user_meta_data->>'full_name', 'New User'),
    'user'
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger definition
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
